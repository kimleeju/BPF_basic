#include <linux/bpf.h>
//#include <linux/in.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_endian.h>
#include <stddef.h>
#define MAP_NAME "packet_count_map"
#define MAX_SEARCH_SIZE 512
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <linux/if_ether.h>

struct tcp_data {
    unsigned char data[64];
};
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, __u32);
    __type(value, __u64);
    __uint(max_entries, 1024);
} packet_size_map SEC(".maps");

static inline int bpf_memcmp(const void *s1, const void *s2, size_t n) {
    const unsigned char *p1 = s1, *p2 = s2;
    while (n--) {
        if (*p1 != *p2) {
            return *p1 - *p2;
        }
        p1++;
        p2++;
    }
    return 0;
}

static inline int find_redis_value_offset(char *data, const char *data_end) {
    const char *search_limit;
    char *search_ptr = data;
    char set_cmd[] = "SET";
    int i;
    // 수정: search_limit 설정을 변경합니다.
    search_limit = data + MAX_SEARCH_SIZE < data_end ? data + MAX_SEARCH_SIZE : data_end;

    for (i = 0; search_ptr + sizeof(set_cmd) - 1 <= search_limit; search_ptr++) {
        if (!bpf_memcmp(search_ptr, set_cmd, sizeof(set_cmd) - 1)) {
            while (search_ptr + 2 <= search_limit) {
                if (*search_ptr == '\r' && *(search_ptr + 1) == '\n') {
                    search_ptr += 2;
                    return search_ptr - data;
                }
                search_ptr++;
            }
            break;
        }
    }
    return -1;
}

SEC("prog")
int drop_all(struct __sk_buff *skb) {
#if 0
    __u32 key = 0;
    //__u64 packet_size = skb->len; // Get current packet size
    unsigned char buf[64] = {0};
    
    bpf_skb_load_bytes(skb, 0, buf, sizeof(buf));
#if 0
    void *data_end = (void *)(long)(skb->data_end);
    void *data = (void *)(long)(skb->data);

    int offset = find_redis_value_offset((char *)data, (char *)data_end);
#endif
    // Update the BPF map with the current packet size
    //bpf_map_update_elem(&packet_size_map, &key, &offset, BPF_ANY);
    //bpf_map_update_elem(&packet_size_map, &key, &packet_size, BPF_ANY);
    bpf_map_update_elem(&packet_size_map, &key, &buf, BPF_ANY);
    return -1;
#endif



#if 1
    __u32 key = 0;
    struct tcp_data tcp_data = {0};

    if (skb->protocol != bpf_htons(ETH_P_IP)) {
        return -1;
    }
 
    __u64 offset_mac = 0;
    __u64 offset_ip = offset_mac + sizeof(struct ethhdr);
    struct ip iph = {};
    bpf_skb_load_bytes(skb, offset_ip, &iph, sizeof(iph));

    if (iph.ip_p != IPPROTO_TCP) {
        return -1;
    }


    __u64 offset_tcp = offset_ip + iph.ip_hl * 4;
    struct tcphdr tcph = {};
    bpf_skb_load_bytes(skb, offset_tcp, &tcph, sizeof(tcph));

    __u64 offset_data = offset_tcp + (tcph.th_off << 2);
    bpf_skb_load_bytes(skb, offset_data, &tcp_data.data, sizeof(tcp_data.data));

    bpf_map_update_elem(&packet_size_map, &key, &tcp_data, BPF_ANY);


#endif
}

char _license[] SEC("license") = "GPL";
